= OPAM support in OBazl

OBazl provides:

* An OPAM bootstrapper tool that generates Bazel files containing
  repository and build targets for everything in the current OPAM
  switch. This makes all OPAM packages accessible under standard Bazel
  labels, such as `@yojson//:yojson` for `yojson` and
  `@mtime//clock/os` for `mtime.clock.os`. The bootstrapper must be
  run before the build; this eliminates the need to run a tool like
  `ocamlfind` during the build in order to integrate OPAM dependencies.
* A toolchain that makes the OCaml compilers and other tools (e.g.
  `ocamllex`) accessible to the OBazl ruleset under standard Bazel
  labels. The toolchain depends on a workspace named `@ocaml`
  containing build targets for the OCaml tools. Executables must be
  targets in the `@ocaml//bin` package; for example, the bytecode
  compiler label is `@ocaml//bin:ocamlc`. This has the useful
  side-effect of making the OCaml tools accessible to `genrule`
  targets. The OPAM bootstrapper generates such a workspace, but since
  the OBazl-defined toolchain depends only on labels, it may be
  replaced with a workspace whose target labels resolve to a
  customized OCaml toolchain.

A primary goal of OBazl is to support fully hermetic OCaml builds. For
reasons explained below, hermetic builds are not possible with a
standard OPAM installation. The remainder of this article describes
the problems and OBazl's approach to addressing them.


== Overview

The OPAM ecosystem is comprised of:

* a link:https://opam.ocaml.org/doc/Manual.html#Common-file-format[configuration language] used to describe OPAM repositories and packages;
* the link:https://opam.ocaml.org/doc/Usage.html[OPAM tool] used to manage OPAM repositories and installations ("switches")
* the official link:https://github.com/ocaml/opam-repository[OPAM repository] (custom repositories are also supported)
* local installations comprised of a set of "switches" and associated artifacts

An OPAM switch is comprised of one version of the OCaml toolchain plus
whatever OPAM packages the user chooses to install (using the OPAM
tool). Each switch gets its own set of installed packages, built using
the toolchain of that switch. The toolchain itself is built by OPAM.

An OPAM package is described by a file written in the OPAM
configuration lanuage and usually named `opam` or `<pkg>.opam`. The
metadata in this file includes a URL and checksum for the package
source code, a list of package dependencies, and a build
"recipe". Here are some examples:
link:https://github.com/ocaml/opam-repository/blob/master/packages/camlimages/camlimages.5.0.4/opam[camlimages.5.0.4];
link:https://github.com/ocaml/opam-repository/blob/master/packages/dns-client/dns-client.6.1.2/opam[dns-client.6.1.2];
link:https://github.com/ocaml/opam-repository/blob/master/packages/yojson/yojson.1.7.0/opam[yojson].

NOTE: the OPAM files for the `base-*` packages are essentially empty,
containing only opam-version, maintainer, and description fields.

The build recipe may use any tools. Many packages use link:https://dune.build/[dune], but
other build tools are also common, such as `make`, link:https://github.com/ocaml/ocamlbuild/blob/master/manual/manual.adoc[ocamlbuild], link:https://github.com/ocaml-omake/omake[omake], link:https://github.com/ocaml/oasis[oasis], etc. Some examples:

* link:https://github.com/ocaml/opam-repository/blob/master/packages/cmdliner/cmdliner.1.0.2/opam[cmdliner.1.0.2] - `ocaml pkg/pkg.ml build ...`
* link:https://github.com/ocaml/opam-repository/blob/master/packages/ppx_import/ppx_import.1.3/opam[ppx_import.1.3] - ocamlbuild

* link:https://github.com/ocaml/opam-repository/blob/master/packages/leveldb/leveldb.1.2.0/opam[leveldb.1.2.0] omake

* link:https://github.com/ocaml/opam-repository/blob/master/packages/planck/planck.2.2.0/opam[planck.2.2.0] -  `ocaml setup.ml -build`

The OCaml compiler itself is built by `./configure` and `make`.


==== External foreign dependencies

OCaml packages may depend on non-OCaml external libraries. A few examples:

* link:https://github.com/ocaml/opam-repository/blob/master/packages/leveldb/leveldb.1.3.0/opam[leveldb.1.3.0] - OCaml bindings for Google's LevelDB library

* link:https://github.com/ocaml/opam-repository/blob/master/packages/zarith/zarith.1.9.1/opam[zarith] - uses GMP

* link:https://github.com/ocaml/opam-repository/blob/master/packages/zlib/zlib.0.6/opam[zlib.0.6] - Bindings to the zlib compression library

Such dependencies will generally _not_ be mentioned in the `opam` file
(except informally, in the documentation string). But the build recipe
may provide a hint, for example by referring to the local system in
the build recipe, as in this fragment from `zarith.1.9.1` opam file:

```
  ["./configure"] {os != "openbsd" & os != "freebsd" & os != "macos"}
  [
    "sh"
    "-exc"
    "LDFLAGS=\"$LDFLAGS -L/usr/local/lib\" CFLAGS=\"$CFLAGS -I/usr/local/include\" ./configure"
  ] {os = "openbsd" | os = "freebsd"}
```


But generally you will need to inspect the sources to determine the
exact dependencies. Even then, details on the dependency are rarely
provided. Often the package will simply include source code that
depends on whatever the build system can find in the local system. In
the above examples, the packages contain code that depends on headers
and library code for external libraries, but say nothing about how
this should be made available; they do not even mention which versions
are needed. At most, they include a dependency on an OPAM pkg-conf
virtual package that ensures that _some_ version of the needed library
is installed on the system. Needlesss to say, such packages compromise
hermeticity.

Furthermore, packages may depend on libraries produced by other
languages, such as `Go` or `Rust`. The source tarball might include
the foreign-language sources for the library, in which case the OPAM
build recipe would include directives for using the toolchain of the
language to build those sources. In that case, the toolchain will be
expected to already be installed on the local system, which again
compromises hermeticity (since the foreign toolchain itself is
unconstrained).

To acheive hermetic builds with such packages, the external resources
must be integrated into the Bazel build system. The OBazl rules can
depend on libraries produced by other compilers (C/C++, Rust, Go,
etc.) so long as they obey the standard C-based linkage conventions of
the operating system. More precisely, the OCaml compilers can link
such code, and the OBazl rules can arrange for this using a small set
of attributes (e.g. `cc_deps`, `cc_linkopts`, etc.).

But it is up to the developer to ensure that such libraries are
produced hermetically, and that means writing Bazel build targets for
them. For the most commonly used languages (C/C++, Rust, Go, Java,
Javascript, etc.), Bazel rulesets are available and can be used to
implement hermetic builds. In some cases, tools are available to
automate generation of the needed Bazel code. For Go, the
link:https://github.com/bazelbuild/bazel-gazelle[gazelle] tool can do
this; for Rust, the tool is
link:https://github.com/google/cargo-raze[Raze]. For C/C++ projects
that use the configure/make build system,
link:https://github.com/bazelbuild/rules_foreign_cc[rules_foreign_cc]
usually works quite well.


