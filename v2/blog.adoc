= OBazl version 2 preview

OBazl is a Bazel Language Support Pack (LSP) for OCaml. This article
provides a preview/overview of OBazl version 2.

The OCaml build discipline is notoriously daunting. The most common
advice to those who want to know how to build OCaml software runs
along the following lines: "Just use Dune, and let Dune worry about
the gory details; you don't need to know". Even worse, this is
probably good advice. Information about the OCaml build discipline is
hard to find. For example, the search algorithm used by the compiler
to find the things it needs to do its work is a critically important
piece of information, but the official documentation for the compilers
does not even mention it. OBazl aims to make OCaml build programming
easy, efficient, and transparent.

== The Foundation: Bazel

Bazel is a build engine with a specialized build API exposed through
the Starlark language (a Python dialect). So Starlark is effectively a
DSL for building software (just as the TeX language is a DSL for
typesetting documents). Bazel ruleset authors effectively extend the
Starlark language by defining language-specific build rules and other
resources (e.g. functions, aspects, etc.) - rather like LaTeX extends TeX.

Users of OBazl get all the benefits of Bazel, including but not limited to:

* Immutable sources. Bazel builds never write to the source tree. For
  projects that require the ability to do so Bazel provides an escape:
  `bazel run` targets can write anywhere. For example, the OCaml
  compiler sources include some `promote` targets; the job of such a
  target is to generate a new version of a source file and overwrite
  the old version, so that the new version can be checked in to
  version control. This can be accomodated by writing custom rules
  designed to be executed by `bazel run <target>`.

* Sandboxed builds.

* Transparency. Bazel exposes just about all information involved in
  building software. With a few simple commands you can inspect, for example:
  ** the Bazel build environment
  ** build targets - running `bazel aquery <target>` will display a
     complete description of all actions executed by the target,
     without actually executing them. The description includes inputs,
     outputs, and the command line.
  ** the complete dependency graph of any target

* Powerful query facilities. For example, you can print the dependency paths between two targets.
* Integrated support for multiple languages
* Remote caching and execution

* Hermeticity.  (Replicable builds)

The OBazl rules themselves extend Bazel to support the build
functionality and patterns needed by OCaml developers.

== Toolchains

OBazl version 1 depended on the `ocamlfind` program. It expected to
find the program in a local OPAM installation, and it generated build
commands that used `ocamlfind` to drive the compiler.

Version 2 eliminates this dependency. The OBazl toolchain depends only
on an OCaml toolchain; it does not essentially depend on OPAM. It
generates build commands that directly use the compiler commands
(`ocamlc`, `ocamlopt`, etc.).

The OCaml toolchain used by the OBazl toolchain must be configured.
Since OPAM-built toolchains are very widely used, version 2 only has
built-in support for such toolchains. Configuration of support for the
OBazl toolchain is handled by the OPAM bootstrapping tool that also
configures OPAM packages for OBazl use; see below for more information
on this.

A future version of OBazl will support configuration of arbitrary
OCaml toolchains.

== Separate compilation and split dependencies.

One of the distinguishing features of OCaml is its support for
separate compilation of interfaces and implementations. But there is
more to it than just separate compilation. Dependencies can also be
expressed independently - _if_ the build tool supports it.

In OBazl, each source file gets a build rule: for implementation
files, `ocaml_module`; for interface files, `ocaml_signature`. This
affords fine-grained control over all build paramters; in particular,
it enables _split dependency graphs_. Implementation and inteface
files have their own dependency graphs, so it is possible to optimize
them; for example in many cases interface files will only depend on
other interface files, and this can be easily expressed with OBazl.
Standard Bazel query facilities can then show the separate dependency
graphs. Optimizing dependency graphs in this way can have performance
implications for builds. Implementations depend on interfaces, but
(pure) interfaces need not depend on modules. If interface
dependencies are expressed as module dependencies, then changes to a
module will trigger recompilation of all interfaces that depend on it
(and hence all modules that depend on those interfaces), even if they
really only depend on its interface. If interfaces only depend on
interfaces, then changes to an implementation file will not trigger a
rebuild of interfaces.

The downside of one-rule-per-source-file is that you need one rule per
source file. Many (most?) OCaml build systems support some form of
"dynamic" dependency resolution, so that the user need not bother with
a complete listing of inputs. Genuine dynamic dependency discovery is
disallowed by Bazel, since it is incompatible with Bazel's primary
goal of ensuring replicable ("hermetic") builds. On the other hand,
Bazel does support _configurable_ dependencies - dependencies that are
resolved during the initial analysis phase of a build - but only if
they resolve to resources that were already registered as build
inputs. The classic case is selection of a platform-dependent source
file at build time. The selected file will not be known before
building, but the set of files from which the selection must be made
_will_ be known before the build commences.

Writing one rule per source file is an obvious candidate for
automation. Version 1 of OBazl did not include any tools to handle
this, but version 2 includes one tool to generate `BUILD.bazel` files
from a tree of source files, and another to convert `dune` files to
`BUILD.bazel` files. To assist with ongoing maintenance, it also
includes a batch editing tool that allows developers to script the
editing of `BUILD.bazel` files.

== Module bindings

OBazl version 2 introduces the concept of _module binding_. This is not a new
concept; it just make explicit what is already implicit - and usually
unmentioned - in the language and compiler designs.

An OCaml module binds an interface to an implementation. This is true
even for implementation (.ml) files that do not have a corresponding
interface file. In that case, the compiler will infer the interface,
extract the implied `.mli` file, and compile it before proceeding to
compile the `.ml` file. (The ability to compile such stand-alone `.ml`
files is thus a feature of the compiler, not the language.)

Module bindings are expressed in OBazl using the `ocaml_module` rule.
The `sig` attribute takes the label of an `ocaml_signature` target;
for stand-alone implementation files, `sig` is omitted. Since
dependencies are expressed using Bazel labels, an `ocaml_module`
target can bind implementation and interface files from any directory
in the project.

Separation of interface and implementation targets eliminates the need
for any concept of "mli-only modules". This is an oxymoron from the
OBazl perspective, since a module by definition binds an interface and
an implementation; if one or the other is missing, then it is not a
module. In OBazl, `ocaml_signature` targets are first-class citizens
and can serve as dependencies just as easily as `ocaml_module`
targets can. In particular, there is no need for a special annotation
to mark interface components of an archive or library (e.g. Dune's
`modules_without_implementation` field).

The module binding mechanism also eliminates the need for special
"virtual" modules and libraries. The problem for which Dune invented
the notion of virtual modules and libraries is the need to select a
particular platform-dependent implementation to bind to a
platform-independent interface. OBazl handles this with the standard
`select` mechanism provided by Bazel. An `ocaml_module` can select an
implementation source file based on whatever configuration constraints
the developer cares to define. Often this will be the operating system
or CPU architecture. The files can have any name and be located in any
directory. The rule will automatically symlink the selected file to a
filename that matches the interface file, so that the module has the
expected name and location. That's all there is to it.

Incidentally, the same standard `select` function can be used to
configure dependencies, thus eliminating the need for Dune's
`alternative dependencies.` It is also used to configure compile/link
options.

Here is an example
from the OBazl PoC build for the OCaml compiler:

.link:https://github.com/obazl-repository/ocaml/blob/0721e1282a956342ab4083562d02309401678ee4/asmcomp/BUILD.bazel#L1264[asmcomp/BUILD.bazel]
```
bootstrap_module(
    name   = "Proc",
    struct = select({
        "//config/arch:x86_64": "//asmcomp/amd64:proc.ml",
        ... etc. ...
        "//config/arch:s390x"   : "//asmcomp/s390x:proc.ml",
    }, no_match_error = "unknown arch"),
    sig    = "Proc_cmi",
     ... [deps etc. omitted] ...
)
bootstrap_signature(
    name = "Proc_cmi",
    src  = "proc.mli",
     ... [deps etc. omitted] ...
)
```

.link:https://github.com/obazl-repository/ocaml/blob/0721e1282a956342ab4083562d02309401678ee4/config/arch/BUILD.bazel#L76[config/arch/BUILD.bazel]
```
config_setting(name = "x86_64",
               constraint_values = ["@platforms//cpu:x86_64"])
... other conf_setting targets omitted ...
config_setting(name = "s390x",
               constraint_values = ["@platforms//cpu:s390x"])
```

In this example, the rule for `Proc` selects a `proc.ml`
implementation file from an architecture-specific subdirectory, and
binds it to the interface file compile by the `Proc_cmi` rule. The
selection is governed by the `config_setting` targets; the
`config_setting` rule supports much more complex selection
configurations as well.

The implementation files in this example all have the same name but
are in different directories. Alternativelly, they could all be in the
same directory, with names like `proc_x86_64.ml`,
`proc_s390x.ml`, etc. Either way, the `ocaml_module` rule will arrange
for files to be copied,  renamed and or symlinked as needed.

== Dependency Managment

Managing OCaml dependencies is a major pain point for hand-written
build scripts. OBazl makes dependency management relatively painless.

* Targets must list their direct dependencies.

* Targets can depend on stand-alone interfaces.

* Interface and implementation dependencies are directory-independent,
  but OBazl always presents them to the compiler in the same
  directory, which mitigates the risk of encountering the dreaded
  "Inconsistent assumptions about interface" error.

* Dependencies may be listed in any order. OBazl will always put them
  in dependency order.

* Dependencies are transitive. Each build target delivers, in addition
  to whatever it builds, its complete transitive dependency graph.

* Dependency graphs are always normalized. Bazel always merges
  dependencies, retaining dependency ordering and removing duplicates.

=== OPAM dependencies

OBazl version 1 gave special treatment to OPAM dependencies. The build
rules had OPAM-specific attributes such as `deps_opam`, and the
repository rule responsible for configuring OPAM support did some
naughty things that compromised hermeticity and efficiency. Version 2
contains no special logic for OPAM; the opam-specific attributes have
been removed, and OPAM dependencies are treated the same way as any
other dependency.

To enable this version 2 includes an OPAM bootstrapping tool whose job
is to generate, for each OPAM package, a repository rule (which
determines a Bazel workspace) and a BUILD.bazel file that uses a new rule,
`opam_import`, to add the compiled code (`.cma`/`.cmxa`/etc files
built by OPAM) to the dependency graph. The labels for OPAM targets
map directly to their OPAM names; for example:

* `yojson => @yojson//:yojson`
* `mtime.clock.os => @mtime//clock/os`.

One advantage of this approach is that workspaces can be overriden to
resolve to the local filesystem. So the maintainer of an OPAM package
can edit the package sources on the local disk, and use the
`--override_repository` so that references to the package will be
redirected to the edited version.

== Aggregates: libraries and archives.

OBazl makes a clear and firm distinction between the concepts
`library` and `archive`.

A _library_ is just an aggregate - a collection of compiled modules,
interfaces, and possibly other resources, such as data files.
Libraries are expressed in OBazl using the `ocaml_library` rule. A
target using this rule lists its contents in a `manifest` attribute;
the content elements, being expressed as Bazel labels, can be located
anywhere in the project.  An `ocaml_library` may contain
other libraries.

An `ocaml_library` does not execute an action. It does not build
anything; rather, it just collects the dependencies listed in its
`manifest` attribute and delivers them to its clients. Its power lies
in its ability to aggregate any collection of targets from anywhere in
the project workspace. For example, this makes it easy to organize
source code along conceptual lines. Instead of stuffing a lot of files
into a single directory, you can create a hierarchy of directories
where each corresponds to some concept. Each such directory can have
its own `ocaml_library`, which will depend on the `ocaml_library`
targets of whatever other directories it depends on,



An _archive_ is a library packaged as an OCaml archive (`.cma/.cmxa`)
file. Like an `ocaml_library`, an `ocaml_archive` target lists its
contents in a `manifest` attribute, but unlike `ocaml_library` it
executes a build action that constructs an OCaml archive. An
`ocaml_archive` may contain `ocaml_library` targets, but may not contain
other `ocaml_archive` targets.


== Namespaces - topdown and bottomup

Namespaces - Dune calls them "wrapped" libraries - are very commonly
used, if only because the Dune `library` stanza builds them by
default. OBazl provides support for two distinct namespace models,
top-down and bottom-up.

A namespace is a collection of modules and/or interfaces named with a
namespace prefix (such as `Stdlib\__`), together with _resolver_
module containing an aliasing equation for each submodule (e.g.
`module List = Stdlib__List`). (What OBazl calls a "resolver" is
sometimes called a "mapper" or "wrapper".) A namespace may be packaged
as an OCaml archive, but this is not a requirement; under OBazl,
bottom-up namespaces may be aggregated using `ocaml_archive` or
`ocaml_library`, or may not be aggregated at all.

Top-down namespaces are defined at the aggregate level. This is the
strategy pursued by Dune: membership in a namespace is expressed by
the list of modules in a `library` stanza. Dune automatically renames
them, adding the namespace prefix (e.g. `Foo__`) to the filenames, and
generates the resolver module containing the required module aliasing
equations . To support top-down namespaces, OBazl provides rules
`ocaml_ns_archive` and `ocaml_ns_library`; members of the namespace
are listed in the `submodules` attribute. OBazl does the same thing
Dune does: generates the resolver and renames the submodules. Both Dune
and OBazl support user-defined resolver modules for top-down
namespaces. Dune always packages namespaces in archives, but in OBazl
they may be organized as libraries.

Top-down namespaces are easy to define, but they are limited. Targets
that use a namespaced module must depend on the aggregate containing
the module; they cannot depend directly on submodules. If changes are
made to a submodule, all targets that depend on its namespace will be
rebuilt, whether or not they depend on the module that was changed.

Bottom-up namespaces eliminate this shortcoming. Targets may depend
directly on namespaced modules; furthermore, bottom-up namespaces need
not be organized as `library` or `archive` aggregates at all. They are
determined by defining an `ocaml_ns_resolver` specifying the namespace
prefix and listing its submodules. The submodules (which may include
interfaces) indicate their membership in a namespace directly, by
passing an `ocaml_ns_resolver` target label via the `ns` attribute of
`ocaml_module` and `ocaml_signature`.

Bottom-up namespaces are much more powerful and flexible than top-down
namespaces. Targets can depend directly on namespaced submodules; this
can be used to optimize builds. When a bottom-up submodule is changed
only targets that depend on it are rebuilt. And since aggregation and
namespacing are orthogonal, namespaced submodules can be aggregated
_ad libitum_. For example, if a set of targets depends on a subset of
three submodules in a namespace that contains ten submodules, this
subset can be aggregated as a library or archive. Multiple aggregates
can contain submodules from the same namespace. Aggregates can even
contain submodules from multiple namespaces. The OBazl rules will
ensure that the _resolver_ module is always included in the dependency
graphs of submodules, and OBazl's dependency manager will always
normalize the graphs to remove duplicates while retaining dependency
order.

As an example: just about everything in the OCaml compiler sources
depends on the standard library, which is packaged as an archive
`stdlib.cma` built by target `//stdlib`. If those dependencies are
expressed as dependencies on `//stdlib`, then a change in any stdlib
submodule will trigger a rebuild of almost everything. But if they are
expressed as direct submodule dependencies, e.g.
`//stdlib:Stdlib.List`, then the rebuild triggered by a change to one
submodule will include only those targets that genuinely depend on it,
directly or indirectly. (link:https://github.com/obazl-repository/ocaml/blob/bazel/parsing/BUILD.bazel[parsing/BUILD.bazel])

== Preprocessing

Most preprocessing tasks can be handled by Bazel's standard `genrule`,
which is designed to run shell scripts. OBazl version 2 adds some new
rules to support standard code generation tools, such as `ocaml_lex`
and `ocaml_yacc`.

PPX processing is a little more complicated, and requires some
specialized support. OBazl provides one specialized rule,
`ppx_executable`, and a collection of ppx-specific attributes on
`ocaml_module` and `ocaml_signature` rules, including:

* `ppx` takes the label of a `ppx_executable` target; the executable will be used to preprocess the source file;
* `ppx_args` is used to pass command args to the `ppx_executable`
* `ppx_data` passes data files needed at `ppx_executable` runtime
* `ppx_print` controls the form of PPX processing output, either `binary` or `text`

Some PPX transformers inject dependencies into the sources they
transform. Dune calls these "runtime" dependencies, but this is
inaccurate; they become _compile-time_ dependencies of the files
output by the PPX transformation. OBazl version 1 called these _adjunt
dependencies_, for lack of a better term; version 2 calls them _ppx
co-dependencies_. They are passed to the `ppx_executable` through a
`ppx_codeps` attribute.
