= OBazl Version 2: Preview
==============================
:toc: left

OBazl is a Bazel Language Support Pack (LSP) for OCaml. This article
provides a preview/overview of OBazl version 2.

*Intro*
The OCaml build discipline is notoriously daunting. The most common
advice to those who want to know how to build OCaml software runs along
the following lines: "Just use Dune, and let Dune worry about the gory
details; you don't need to know". Even worse, this is probably good
advice. Information about the OCaml build discipline is hard to find.
For example, the search algorithm used by the compiler to find the
things it needs to do its work is a critically important piece of
information, but the official documentation for the compilers does not
even mention it.

NOTE: Version 2 contains many improvements over version 1, but this
article does not discuss specific differences. They will be listed in
a changelog when version 2 is released.


The development of OBazl was largely motivated by dissatisfaction with
this state of affairs. 1. intentional lack of transparency 2. lack of info about how the compilers work (e.g. search paths, )

where Dune's opacity is annoying:
* build cmds
* depgraphs
* namespacing
* preprocessing
* build environment, including tools and output dirs

= Transparency
So the first order of business was transparency, and Bazel supports a great deal of transparency out-of-the-box:

* `bazel aquery <target>` prints cmd line and inputs/outputs, without running a build
* the `build` command always prints the path of its outputs
* target labels are "homo-indexical" - they cause the generation of
  outputs (indexicality), and the form of a target label maps directly to
  the form of the output names (both are paths). So the form of target and dependency labels in the build program text already tells you what will be produced, where. [FIXME: homo-indexicality is not a necessary feature of target labels; a rule can put its output elsewhere; but they are, generally, in OBazel. TODO: list cases where they are not]
* `bazel info` prints the info you need to inspect the build environment:
  ** `bazel info command_log` tells you where you can find the log that Bazel writes for every command
  ** the `external` subdir of the path printed by `bazel info output_base` is where you can find external repos
  ** `bazel info output_path` tells you where outputs are placed
     (normally a system `/var` or `/tmp` dir symlinked to `bazel-out` in the
     project root dir)

Dune treats the build commands it generates as implementation detail
best hidden from the programmer. OBazl takes the opposite approach:
maximal transparency is a major design goal, and even where
higher-level abstractions encapsulate lower level detail, it should
always be not just possible but easy to obtain information about the
details. So for example inspection of the commands generated by Bazel
build rules is trivial, thanks to Bazel's querying facility: `bazel
aquery <target>` tells Bazel to print the command line generated for
the target, plus the complete list of its inputs and outputs. As a
bonus, Bazel can do this without actually running the build, so no
matter how large your project is, you can inspect the build command
for any target without waiting for a build to complete.

= Design principles and goals:

=== Transparency

A primary design goal of OBazl is transparency. It should be possible
  with little effort to see exactly what Bazel does when it builds a
  target. Fortunately we get this for free from Bazel: the query
  facility can print, for any build target, the command line generated
  by the rule and the complete list of inputs and outputs. [TODO:
  mention other diagnostics features supported by the rules, e.g.
  aspects, `--output_groups=fileset`?]

=== Faithfulness (immediacy?)

Build rules should map as directly as possible to the toolset. That
  is, rules should generate command lines that directly use tools from
  the OCaml toolchain, and the mapping from the rule expressed in the
  build file to the generated command line should be direct and
  transparent.

=== Parsimony

Each build rule should do one (minimal) thing, without side-effects.

What does the OBazl ruleset do that Bazel could not do using just
genrules? Mainly dependency management. One could write genrules to
compile things, but getting the deps right would be hard.

So the definition of "minimal requirements" for OBazl rules is a
matter of judgement. "Minimal" means the least required to meet our
design goals, not the least possible.

In fact, the only indispensable part of OBazl is the toolchain definition.
All build tasks could in principle be accomplished using `genrule`,
using the tools provided by the OBazl toolchain definition.

Minimal requirements:

* compile .ml and .mli files
* link archive files
* link executables
* link to C/C++ libs. this is not strictly speaking a requirement for
  OCaml; it's not something the compiler does, its something the
  linker does. But that's part of the standard build toolset and it is
  not something that can be handled separately, so it counts as a
  minimal requirement, even though most projects won't need it.
* manage dependencies automatically. a requirement not in the sense
  that builds would otherwise be impossible, since deps could always
  be handled manually, but rather a requirement imposed by a design
  goal, namely, make developing with OBazl as simple, clear, easy, etc.
  as possible.
* support for toolchain variants:
  ** opam installation
  ** standard direct installation w/o opam, e.g. via brew on Macos, apt-get, etc. (https://ocaml.org/docs/install.html)
  ** custom install from sources: https://github.com/ocaml/ocaml/blob/trunk/INSTALL.adoc


A truly minimal LSP for ocaml - or any language, for that matter -
would contain no build rules at all. The built-in `genrule` (general
rule), designed to run shell scripts, could in principal be used to
implement all the steps of any build, just as any build could be
expressed using nothing but shell scripts. The only indispensable part
of an LSP is the toolchain definition that is responsible for
integrating built tools (compilers, linkers, etc.) into the Bazel
system, so that they become available for use in `genrule` targets.

[Maybe we should introduce a concept of "core" or "kernel"
 functionality, since "minimal" is hard to pin down.]

To support clarity, simplicity, etc. a major design goal was to
implement a core set of rules with the simplest possible capabilities
needed to support composition of more powerful abstractions.

I'm struggling with how best to express this. But I can easily put it
in the negative: what we do _not_ want to do is what Dune does, namely
present only high-level stuff and keep the details behind the curtain.
We want to make it easy for the developer to always see exactly what
OBazl is doing, and we want to make it easy for developers to compose
builds, and even to e.g. write macros or custom rules compositionaly.

The task of the Bazel rule developer is to design function-like rules
that translate their arguments into the command line instructions that
drive the build tools. This frees the user from having to worry about
the precise syntax of build commands. In addition, build rules usually
automate dependency management, may implement additional
functionality. In the case of OCaml, the latter could include handling:

* the tasks required to support namespacing (Dune: "wrapped" libraries)
  ** renaming the namespaced modules to add the namespace prefix
  ** generating the _resolver_ module containing the module aliasing equations needed to support the namespace
* `PPX`  and other preprocessing tasks
*  the details involved in linking foreign-language libraries (usually via the standard C interface)


    Unix philosophy: each tool accomplishes one well-defined task.

    Parsimony: tasks are minimal

    Separation of Concerns

        One rule for each build task: sigs, modules, archives, executables

        Module deps v. Sig deps

Not minimal (or: not core) requirements:

* integrated generic preprocessing. The compilers do support preprocessing,
  but this is added functionality that has nothing to do with
  compiling OCaml code. All preprocessing can be handled separately,
  before the build. That's why it's call _pre_processing, after all.

To be clear, it is not that preprocessing support is not required; it
is just not required as a feature of the minimal OBazl rules.

* namespacing. Like preprocessing, support for namespacing is a
  practical requirement, but is not a minimal requirement. Namespacing
  can be implemented by hand, without special support from build
  tools.

* special support for OPAM pkgs

[The point of all this blather about minimal this-and-that is to emphasize
composiitonality; the rules start with the "kernel" functionality,
then we add stuff needed to make a nicer user experience, etc. It's
not always compositional on the surface; for example adding support
for ppx is not the result of composing a ppx element with a basic rule
element. Although we could have done it that way: define a
`ppx_transformation` rule responsible for running the transform, and
have the `ocaml_module` rule depend its output. Maybe I'll
implement that, if only for demo purposes.]

=== Compositionality


Build rules should be composable. The semantics of
  compositionality is simple: the meaning of the whole must be the sum
  of the meanings of the parts. But semantics alone is insufficient;
  we also want the language to be compositional. That is, it should be
  possible to read the compositionality of the build from the
  compositionality of the build program.

Reducing complexity and reptition by composing mashups. For common
patterns, OBazl provides predefined higher-level functionality, e.g.
ppx attributes.

* Case: ppx support

* Case: namespacing support (automatic renaming; autogenned resolvers)

* Case: common config patterns: linkall, keep_locs, etc. Both global
  and rule-specific, e.g. `@ocaml//noassert` v.
  `@ocaml//module/linkall` etc.

=== Expressivity

The build language (Starlark plus the OBazl rules)
  must allow the developer to express build structure clearly and at
  the desired level of abstraction, independently of the
  expressiveness of the compiler command line "language". For example,
  support for a "business concept" may be distributed across multiple
  files and directories; the language should allow the developer to
  express the concept, in the build language, in a way that abstracts
  from the details. See below [x] for an example.


OBazl can express composites that have no corresponding built
artifact. For example, the `ocaml_library` rule expresses the
composition of a list of modules and signatures (.cm[xo] and .cmi
files). The rule does not build anything, it just aggregates its input
dependencies; the output it delivers is its dependency graph, merged
and ordered. Furthermore, such a library may depend in other
`ocaml_library` targets. This makes it possible to express a build
structure in terms of whatever groupings make sense to the developer.
For example, the OCaml compiler Makefiles express similar
compositionality using rules like the following:

```
COMMON_CMI = $(UTILS_CMI) $(PARSING_CMI) $(TYPING_CMI) $(LAMBDA_CMI) $(COMP_CMI)
COMMON = $(UTILS) $(PARSING) $(TYPING) $(LAMBDA) $(COMP)
...
PARSING = \
  parsing/location.cmo \
  parsing/longident.cmo \
  ...
PARSING_CMI = \
  parsing/asttypes.cmi \
  parsing/parsetree.cmi
...
compilerlibs/ocamlcommon.cma: $(COMMON_CMI) $(COMMON)
    ... build action ...
```

One problem with this is that the rules for building the `.cmo` and
`.cmi` files may be listed just about anywhere - the codebase contains
48 Makefiles. With OBazl we can make this much more direct and
transparent. First of all, Bazel does not support Make-style pattern
rules - it will not infer a build rule from a file extension, for
example. The rules for building things are encoded in the OBazl rules,
and we must write one target (apply an OBazl rule) for each file we
want to compile. So we localize the rules for building modules and
signatures; for example the rule to build `parsing/location.cmo` is in
`parsing/BUILD.bazel`(here we use the `bootstrap` ruleset, but the
same principles apply to the standard `ocaml_` ruleset):

[source,bazel]
```
bootstrap_module(
    name   = "Location",
    struct = "location.ml",
    ...
```

(Yes, writing such rules by hand is tedious, but you only have to do
it once, and the OBazl toolset includes tools for automatically
generating such rules; see below.)

Then we add a `bootstrap_library` (equivalently for ordinary projects:
`ocaml_library)` target for each aggregate - in this case, we would
add (to `parsing/BUILD.bazel`):

[source,bazel]
```
bootstrap_library(name = "parsing", manifest = [":Location", "Longident", ...) ...)
```

Now our `ocamlcommon` archive can depend on these libraries:

[source,bazel]
```
bootstrap_archive(
    name = "ocamlcommon",
    mode = "bytecode",
    modules  = [
        "//utils",
        "//parsing",
        ...
        ])
```

Since an `ocaml_library` can contain other ocaml_libraries (i.e.
depend on the modules and signatures they aggregate), a hierarchy of
source code can easily be "rolled up" into a single target. For
example, suppose we have a concept (i.e. module) A whose dependency
graph contains code that can in turn be partitioned into several
distinct concepts, say B and C. With OBazl it is easy to implement
such code in a hierarchy of directories `a/b/c`, each of which
contains the source files supporting the concept. Then `a/BUILD.bazel`
might contain an `ocaml_library` target named `A` that depends on an
`ocaml_library` target named `B` defined in `a/b/BUILD.bazel`, which
would depend on an `ocaml_library` target named `C` defined in
`a/b/c/BUILD.bazel`. Client code that needs to use module A would then
depend on `//a:A`. For an example, see link:https://github.com/obazl/dev_obazl/tree/main/demos[TODO: ref
to demo].

== Simplicity

= The OCaml Build Discipline

NOTE: This section provides a high-level description the concepts
involved in building OCaml software, the problems OBazl tries to solve
and the concepts it relies on to solve them.


== Module Bindings

Interface + Implementation

`ocaml_signature`, `ocaml_module`

Module Bindings - Dune's link:https://dune.readthedocs.io/en/stable/variants.html?highlight=virtual%20modules#virtual-library[virtual libraries]

== Aggregates

library v. archive

In contrast to other build systems, and the OCaml community in
general, OBazl makes a distinction between the concepts `library` and `archive`.

An OBazl _library_ is just an aggregate - a collection of
compiled modules, signatures. An `ocaml_library` target lists its
contents in a `manifest` attribute: it constructs nothing and delivers
its contents as a list in dependency order.

An _archive_ is a library packaged as an OCaml archive (`.cma/.cmxa`)
file. Like an `ocaml_library`, an `ocaml_archive` target lists its
contents in a `manifest` attribute, but unlike `ocaml_library` it
executes a build action that constructs an OCaml archive. An
`ocaml_archive` may contain `ocaml_library` deps, but may not contain
other `ocaml_archive` deps (since the OCaml compiler will not accept
archives as input to an archive build command).

== Namespacing

=== Top-down



=== Bottom-up

* bottom-up ns does not automatically entail and aggregate. Aggregates
  containing namespaced modules must be explicitly defined, and they
  may contain a subset of the submodules in an ns, or submodules from
  multiple namespaces. IOW, aggregation and namespacing are orthogonal.

* clients cannot depend on a namespace; they can only depend on
  aggregates or singletons (modules, sigs).

* a change to a submodule in a ns will cause a recompile of any
  aggregate that contains it, and of anything that depends on the
  aggregate. but targets that depend on a submod directly will not be
  affected by changes to other submods in the ns. Whereas with a
  top-down ns, targets can only depend on the ns-aggregates, so any
  change in any submodule will force a recompile of all cllients.

* changing one submodule does not entail a rebuild of any sibling submodules.

* the user may provide a custom resolver module, which can be any
  module that contains the module aliasing equations needed to support
  the ns. submodules then just list this module's label in their `ns`
  attribute. This is what happens with the Stdlib modules of the
  compiler.

* supports direct dependency on individual submodules in the
  namespace. We cannot depend on a dotted module path, but we can
  depend on a module in a namespace, and we can use a naming
  convention to me it look like a dotted path. For example, the
  bazelized version of the OCaml compiler uses dotted names for the
  Stdlib; so the target name to compile the `buffer.ml` module of the
  stdlib is `Stdlib.Buffer`; to build it: `bazel build
  //stdlib/Stdlib.Buffer`. NB this is just a convention.

* normalized/optimized build files can be queried to show optimized
  dep graphs i.e. no spurious dependencies. I.e. if you depend on a a top-down
  `ocaml_ns_library`, the dep graph will show a dependency on all
  submodules in the ns lib. With bottom-up namespacing and optimized
  build files no spurious deps will be shown.
* OTOH, if you depend on the `ns_resolver` of a bottom-up namespace,
  the dep graph will not include the submodules, since the submodules
  depend on the resolver, not the other way around. So there are trade-offs.
  ** FIXME: is there a way to write a query that will show the
     submodules too? probably. can this be done by an aspect?

== Dependency Management

=== Dependency classes

* direct and indirect
* module v. interface
* config-time v. build-time v. compile-time v. runtime
* data v. code
* PPX co-dependencies

==== Optional dependencies

solves same problem as Dune's `(select ... from ...)` (
    link:https://dune.readthedocs.io/en/stable/concepts.html#alternative-dependencies["alternative dependencies"])

==== External Dependencies

handled by standard bazel mechanisms


=== discovery v. normalization v. optimization

=== Split dependencies

OCaml interface and implementation files for a given module may have very different dependency graphs.

Since OBazl supports separate builds of .ml and .mli files, users can
optimize by listing (as appropriate) only `cmi` deps for an `mli`
file. Note that dep analysis tools like `ocamldeps` and `codept` will
tell you which _modules_ an interface file depends on, but will not
indicate whether the dependency is in fact only on the `.cmi` file; so
this kind of optimization must generally be done by hand.

Since modules depend on sigs, but not the other way around, this means
that signature dep graphs can be built without causing the build of
any modules, and queries can show just the signature dependency graph
of a target.


=== Configurable ("dynamic") deps


=== Separation of concerns:  dep mgmt v. build

Build tasks involve explicit build commands, but they also always
involve a critical bit of information that is often hidden or only
implicit, namely the graph of the target's dependencies. Dependency
management is a well-known pain point for OCaml builds; the entire
dependency graph of a build target must be made available to the
compiler, and for archive and executable targets, must be listed
explicitly on the command line in dependency order. By and large,
managing dependencies by hand is infeasible for all but the most simple
projects.

The strategy for managing dependencies adopted by Bazel (and thus
OBazl) is starkly different from that of most other build systems.

[FIXME: three points:

* finding and listing deps as input to the build
* transparency of actual depgraphs (inspection using `query "deps(...)`, `aquery`, `--output_groups=closure`, etc.)
* how OBazl normalizes and propagates depgraphs, advantages compared to dune, e.g. ppx_codeps]

Many build systems, Dune included, conflate dependency _discovery_ and
the build process. For example, Makefiles for building OCaml projects
usually run `ocamldep` to generate `.depends` files listing
dependencies, and build targets depend on these dynamically generated
files. Dune build stanzas list direct dependencies, but indirect
dependencies are discovered (using `ocamldep`) and added to the build
dependency graph as part of the build process.

By contrast, Bazel enforces a strict separation between dependency
discovery and the build process. All dependencies must be explicitly
enumerated for Bazel before the build process begins; discovering and
adding a dependency in the course of the build process is disallowed.
This is a necessary feature of any hermetic (replicable) build
process: if you want to design a replicable experiment, you start by
fixing the initial conditions. Build systems that allow dynamic
discovery and injection of dependencies cannot guarantee hermeticity.  [WARNING: this is not accurate, to be revised]

The downside of having to explicitly enumerate the entire dependency
graph for a project is that you have to explicitly enumerate the
entire dependency graph for the project. But this is obviously a task
that can and should be addressed by a build tool, just as it is for
systems that do this discovery during the build process. The only
difference is that for Bazel we run the dependency discovery tool
_before_ the build process commences, and we record its results and
pass them as input to the build process.

Version 2 of OBazl includes tooling that can largely if not entirely
automate the enumeration of dependencies. Currently there are some
cases where it is difficult to discover all dependencies; for example
targets that involve lots of indirection, `-open` arguments and
`include` directives in source files. A goal of the OBazl project is
to perfect this tool so that can always emit complete and correct
dependency graphs.

Another notable feature of OBazl with respect to dependencies is that
we get correct ordering for free, so to speak. Dependency ordering for
compiler inputs, and for most build tools, is expressed syntactically,
as list ordering (which is in part why managing deps in such systems
is difficult). But OBazl maintains dependencies as a graph structure,
so ordering is expressed as hierarchy. The only way to express a
dependency of A on B is to list B explicitly in the `deps` attribute
of A; there is no way to express it as the list `B A`, as one must do
on the compiler command line. In particular, listing `["A", "B"] in a
`deps`` attribute does not express a dependency of B on A. In fact, it
could be the case that A depends on B (either directly or indirectly),
so when we serialize the graph derived from this list we will get `B
A`. It follows that dependencies can be listed in any order; you can
list them in alphabetical order if you wish.

The critical feature here is that Bazel provides out-of-the-box
support for merging dependency graphs. If your dependencies are
expressed as ordered lists, and you have multiple dependencies, then
you have the task of merging the ordered lists in such a way that
dependency order is maintained, which is non-trivial, since the same
item may occur in different contexts in more than one list. [TODO:
simple example]. Bazel provides a `depset` facility that handles such
merging automatically and efficiently. OBazl rules use depsets to
manage all dependencies.

deps that require special handling by the build engine: runtime data
deps; runtime code deps (plugins); ppx-codeps


== Compilation modes

== Metaprogramming

=== PPX

        Special `ppx_executable` rule
        PPX co-deps ("runtime" deps)

PPX support involves some "special" considerations.

* ppx args
* ppx_print
* ppx_codeps must be propagated - attached to the transformation output, then added to the deps for compilation

=== Generalized preprocessing

Minimal: use genrule. But since preprocessing, exp. ppx, is so common, OBazl comes with built-in support.


== FFI

=== C/C++

=== Other languages - Rust, Go, etc.



= OPAM, findlib, and Dune

These tools play a special role in the OCaml build discipline. They
are not necessary - one can build OCaml software without them - but
they are so widely used that any build system must accomodate them in
some manner.

Dune is the most widely-used OCaml build tool. OBazl provides tooling
to automate conversion from Dune to OBazl, and since OBazl can coexist
with Dune some support for automated maintenance is provided.

= The OBazl Rulesets

Core collection of primitives (build rules) that can be composed to accomplish any build task.

The most basic build tasks are compilation of interface and
implementation files, linking of archive files, and linking of
executables. OBazl includes one rule for each of these tasks, named
accordingly: `ocaml_signature`, `ocaml_module`, `ocaml_archive`, and
`ocaml_executable`.

Most real-world projects involve some additional tasks:

* preprocessing of source files, including but not limited to PPX transformations;
* renaming of source files to add a namespace prefix;
* generation of a `resolver` module (sometimes called a "map" file)
  containing the module aliasing equations required to make
  namespacing ("wrapped" libraries in Dune) work.

None of these tasks involve the OCaml toolchain, so (following the
Principle of Parsimony), OBazl does not include rules for them. They
can all accomplished using the standard `genrule` ("general rule")
provided by Bazel.

Here is an example of a simple build pipeline using only OBazl
primitives, to compile a namespaced module with a PPX transformation:

```
source file -> genrule to rename src -> genrule to execute ppx transform -> ocaml_module
```

In this example, the first step would use a shell command (`cp` or
`ln`), and the second step, running a PPX transform, would depend on
the output of another pipeline ending in an `ocaml_executable` that
produces the PPX executable. Both `genrule` steps would involve a
shell command that must be written by the programmer.

In this case Bazel would function more or less as a glorified Make; it
would analyze dependencies and invoke the build actions required by a
change in sources, but would delegate actual build responsibility to
the shell scripts written in the genrules (except for the final
`ocaml_*` rule). So this is not something one would do in practice.
Nonetheless, in principle such composable pipelines could be used to
build any OCaml project. But build files written at such a low level
of detail would be tedious to write, error-prone (since they involve
shell scripting), verbose, and hard to maintain. So in order to meet
its design goals (Ease of Use, etc.), OBazl extends some of its rules
to automate the most common build patterns in a more convenient and
expressive manner, and to take advantage of the Bazel's specialized
build API. For example, instead of passing the PPX executable to a
genrule (which runs a shell command that the developer must write)
that runs it as a separate task, we can pass it directly to the
`ocaml_module` rule via its `ppx` attribute, which has the effect of
directing the rule to run the transform and compiles output. The
transform will still be executed as a separate build _action_, but it
will be managed by the `ocaml_module` rule, so the developer doesn't
have to bother directly with the details of a shell command. The OBazl
rules have also been extended to automate namespacing, so that the
developer is responsible only for annotating the rules with attributes
indicating namespace membership, and OBazl takes care of the rest.

NB: compositionality:  rules v. build actions

OBazl includes two rulesets:

* a `bootstrap` ruleset (rule names prefixed by `bootstrap_`)
* the standard ruleset (rule names prefixed by `ocaml_` or `ppx_`)

== rules_bootstrap

The `bootstrap` ruleset is a special case. It is designed expressly
and solely to support building the OCaml compiler. Building the
compiler requires bootstrapping: the build rules cannot rely on an
OCaml compiler to build the OCaml compiler. Instead they must first
compile the bootstrapping compiler, which is written in C, and then
use it to compile the OCaml sources and produce an OCaml compiler
proper. The standard OBazl ruleset cannot be used to build the
compiler, since it depends on an already-built compiler.

The `bootstrap` ruleset uses a stripped-down version of the standard
ruleset, and replaces the standard toolchain with a toolchain that
uses the bootstrapping tools. The compiler code does not use PPX
preprocessing, and uses only a single hand-coded namespace (the
Stdlib), so it does not need support for general namespacing. So the
bootstrap rules use the same code as the standard ruleset, except that
everything not necessary to build the compiler is stripped out.
Consequently the bootstrap rules are much simpler than the standard
rules, and users interested in knowing how OBazl works should start by
studying the bootstrap rules.

Because the `bootstrap` ruleset is designed only to be used in
building the compiler, it is not distributed with the OBazl package,
nor is it independently downloadable. Instead it is included directly
in the link:https://github.com/obazl-repository/ocaml[OBazl fork of the compiler].

== rules_ocaml
The standard `obazl_rules_ocaml` ruleset can be thought of as a layer
that sits on top of and extends the bootstrap ruleset. It adds support for:

* PPX processing, including automated management of so-called "runtime dependencies"

* Generalized namespacing (automatic generation of "ns resolver"
  modules) to compliment the automatic module renaming supported by
  the bootstrap rules.

* Contingent dependencies - selection of dependencies based on configuration state
  ** corresponds to Dune's "alternative dependencies" using `(select ... from ...)`
  ** no special syntax or functionality is involved; dependencies may
     be selected using Bazel's standard, generic `select` function
  ** NB: this is just a matter of using Bazel's `select` function for deps, so it is available in the bootstrap ruleset.

* Full control over module bindings
  ** A module rule can select any implementation file for binding to
     any particular signature (.cmi) file, based on configuration
     settings; for example, binding `clock.cmi` to a platform-specific
     implementation e.g. `clock_linux.ml` is expressible using a
     simple `select` statement on a single `ocaml_module` target.
  ** Eliminates need for
     link:https://dune.readthedocs.io/en/stable/variants.html?highlight=virtual%20modules#virtual-library["virtual
     libraries"]. Module bindings like this need not be delayed to
     link-time.


== Executables


=== OPAM

Version 1 depended on the `ocmlfind` program and thus on opam metadata
files at build time. Version 2 removes the dependency on `ocamlfind`
and does not depend on any OPAM tools or metadata at build time. Projects may depend
on the compiled files produced by OPAM, which are imported by the
build files produced by the new opam bootstrap tool.

The opam bootstrapping tool writes build files for each OPAM package,
whch makes them just like any other dep. The build files use rule
`ocaml_import` to import the files compiled under the control of `opam
install`. Once those build files are in place, nothing special need be
done to depend on opam packages; all you need is the target label.


= Configuration

    Predefined global configs: `@ocaml//debug`, `@ocaml//module/linkall`, etc.

= Toolchains & Hermeticity

= Tools

== OPAM bootstrapper
* an OPAM bootstrap tool that generates BUILD.bazel files and corresponding repository rules for all packages in the current OPAM switch

== Dune conversion
* a conversion tool that converts dune files to BUILD.bazel files;
     some hand-editing may be required for dune files that contain
     complex `rule` stanzas

== OBazl init
* a conversion tool that generates BUILD.bazel files from scratch
     for any directory containing OCaml source files. The generated
     targets contain dependencies derived from running `codept`, which
     may need to be hand-edited; in addition, namespacing must be
     added by hand.

== sunlark - scripted editing
* a tool that supports scripted (in Scheme) batch editing of BUILD.bazel files


= CI Support

= Docker Support

= Misc

* eliminates need for Dune's `install` stanza
  * dependencies on executables or other built outputs can be
    expressed directly; no need to install and then refer
* supports direct expression of various things that are hard to express in Dune, or that require "tricks"
  ** use of "alternative dependencies" with bogus (empty) libraries in the test condition, to emulate genuine conditional deps (example: tezos `src/bin_node/dune`)
  ** with dune, dependencies on built outputs may require expicit
    hand-coded reference to the build output directory tree; with
    OBazl all such deps can be expressed directly as ordinary target
    deps.  Example: tezos `src/lib_protocol_compiler/dune` contains:

```
    (rule
        ...
           %{dep:.tezos_protocol_registerer.objs/byte/tezos_protocol_registerer__Registerer.cmi}
    ...)
    ...
    (library
     (name tezos_protocol_registerer)
     (public_name tezos-protocol-compiler.registerer)
     ...
```

With OBazl this reference would look something like:
`//src/lib_protoco_compiler:Registerer_cmi`, referencing the
`ocaml_signature` rule responsible for producing the `cmi` file.

What problems does OBazl solve? What can it do that Dune cannot do, or can only do with difficulty?

* virtual modules/libs (http://rgrinberg.com/posts/virtual-libraries/#id4)
* bottom-up namespacing
* cmi deps
* granularity
  ** build one submodule in an ns aggregate
  ** build and inspect cmi-only dep graphs
* hermeticity
