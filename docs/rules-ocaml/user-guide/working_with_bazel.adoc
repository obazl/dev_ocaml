= Working with Bazel
:page-layout: page_tools_opam
:page-pkg: tools_opam
:page-doc: ug
// :page-sidebar: false
:page-permalink: rules-ocaml/user-guide/working-with-bazel
:page-tags: [bazel]
:page-keywords: notes, tips, cautions, warnings, admonitions
:page-last_updated: May 2, 2022
:page-toc: true


Quickstart: the quickest way to get started is to clone and run some of the
link:https://github.com/obazl/dev_obazl[demos].

// * link:#overview[Overview]
// * link:#prerequisites[Prerequisites]
// * link:#bazel[Bazel]
// * link:#setup[Setup]
// * link:#inspection[Inspecting the Bazel environment, logs, actions, etc.]
//   * link:#bazel_info[bazel info]
//   * link:#command_log[command_log]
//   * link:#output_base[output_base]
//   * link:#actions[actions]
// * link:#tips[Useful tips]
// * link:#externals[Working with external repositories]

== Overview

Developing software with Bazel is pretty much like developing software
with any other build system: lather, rinse, repeat. You edit your
sources, execute a build command of some kind, run a test driver or
executable to verify results, and repeat.

The major differences are of course related to the build program and
the build engine. Bazel build programs are written in the Starlark
language, and Bazel is also the name of the build engine (of which
there is only one.)

Bazel provides a great deal of information about your build structure,
and it provides fine-grained control over build actions. You can build
any target in your project, and only it and its dependencies will be
built. You can parameterize your builds at any level of granularity.
If you include appropriate test targets, you can modularize your
development even if your source code is not organized in a modular
manner.

Furthermore, Bazel includes powerful query facilities that make it
possible to explore the dependency structures of your code. You can
easily list the dependency chain between two targets, or list the
targets that have a certain parameter, etc. You can generate SVG
graphs showing dependency graphs of your code.

Bazel also makes it easy to develop multiple, mutually-dependent
projects simultaneously. If your main project depends on an external
repository, you can easily configure your build to use a local copy of
the dependency _without altering your build code_. One benefit of this
is that it makes it easy to eliminate embedded git submodules.

== Prerequisites

* Platform: Linux or MacOS. Both Bazel and OCaml support windows, so
  OBazl may work, but it has not been tested and there are no plans to
  do so. However, it should not be terribly difficult to port it to
  Windows. If you have the time and energy to work on this please
  reach out on the link:https://discord.gg/PHSAW5DUva[OBazl Discord
  server] and I will be happy to help.

* Build tools. The OCaml toolchain depends on a C/C++ compiler and
  tools.

* link:https://opam.ocaml.org/[OPAM] installation. The rules have been used
  with version 2.0.7. Earlier versions may work; if not, please link:https://github.com/obazl/rules_opam/issues[file
  an issue].

  * Currently the OBazl rules only support an OPAM toolchain installed on
    the local host outside of Bazel's control; they do not support
    fully hermetic builds, where all build inputs including toolchains
    are exclusively controlled by Bazel. A future version of the OBazl
    rules will automatically download and install the entire OCaml
    toolchain and required packages into a private, Bazel-controlled
    cache.

* An OPAM link:https://opam.ocaml.org/doc/Usage.html#opam-switch[switch]
  containing the OCaml compiler and OPAM packages your project needs.

  * Instruction for configuring an OPAM switch is beyond the scope of
    this guide, but here are some common useful commands:

    * `$ opam list` - shows all installed packages
    * `$ opam pin list` - shows all "pinned" packages
    * `$ opam config list` - lists all general configuration settings
    * `$ opam config list ounit2` - lists all configuration settings for package `ounit2`
    * `$ opam var` - same as `opam config list`
    * `$ opam var bin` - print the value of the `bin` var of the current switch
    * `$ opam var ounit2:version` - prints version string of package `ounit2`

  * The OBazl rules depend on link:http://projects.camlcity.org/projects/dl/findlib-1.8.1/doc/ref-html/r17.html[ocamlfind], which you must install: `$
    opam install ocamlfind`. `ocamlfind` is an application of
    link:http://projects.camlcity.org/projects/findlib.html[findlib],
    which is an OCaml library manager that compliments OPAM; most if
    not all OPAM packages contain a findlib `META` file, which is used
    by `findlib`-based tools, chief of which is `ocamlfind`. If you
    are new to OCaml you will probably find it worthwhile to
    familiarize yourself with `ocamlfind`.  In particular:

    * `$ ocamlfind list` - shows all packages _and subpackages_. `opam list` does not show subpackages.

    * `$ ocamlfind query ...` - analyzes package dependencies; see
      link:http://projects.camlcity.org/projects/dl/findlib-1.8.1/doc/guide-html/c161.html[Dependency analysis of
      packages]

  * If you use `emacs`, you probably want to install `merlin`.

  * By default, OBazl will use use whatever packages you have
    installed, at whatever version. For production code where you want
    to pin precise versions, you can direct OBazl to verify your
    switch. See
    link:configuration.md#opamconfig[OPAM_Configuration]
    for more information.

* link:tools.md[Tools]

* Locally installed libraries. Some OPAM packages depend on locally
  installed resources. For example, package `bignum` depends on
  package `zarith`, which depends on a local installation of `libgmp`.

== Bazel

link:https://docs.bazel.build/versions/master/install.html[Installation].

TIP: OBazl recommends using link:https://github.com/bazelbuild/bazelisk[Bazelisk] (link:https://docs.bazel.build/versions/master/install-bazelisk.html[Installing Bazel using Bazelisk]).


If you use Bazelisk, you can pin the Bazel version by putting file
`.bazelversion` in the root directory of your project, containing the
required version string, e.g. `3.7.0`.

If you are just getting started with Bazel, you should work through one of the link:https://docs.bazel.build/versions/master/getting-started.html#tutorials[Tutorials]

To work effectively with OBazl you must master the following material at minimum:

* link:https://docs.bazel.build/versions/master/bazel-overview.html[Bazel Overview]
* link:https://docs.bazel.build/versions/master/build-ref.html[Concepts and Terminology]
* link:https://docs.bazel.build/versions/master/guide.html#specifying-targets-to-build[Specifying targets to build]
  * Or: `$ bazel help target-syntax`

For reference:

* link:https://docs.bazel.build/versions/master/guide.html[User Guide]

**WARNING**: a great deal of Bazel documentation is available, but it
  is not always easy to find what you need. If you do find it,
  _bookmark it_! For example, the documentation for `--config` is
  buried at the bottom of link:https://docs.bazel.build/versions/master/guide.html#bazelrc-the-bazel-configuration-file[.bazelrc, the Bazel configuration file].

**WARNING2**: the documentation is not always up to date. Bazel is
  very stable, but it is also under very active development so the
  documentation may lag. For example, the documentation frequently
  refers to `BUILD` and `WORKSPACE` files. Those still work, but at
  some point support was added for `BUILD.bazel` and `WORKSPACE.bazel`
  (which is what OBazl recommends).

OBazl deviates from standard Bazel conventions in a few minor ways:

* Rules that build executable binaries are named `*_executable`, not
  `*_binary`: `ocaml_executable`, `ppx_executable`

* Library rules (`ocaml_library` and `ppx_library`) do not build
  "separately compiled modules". Instead they provide a simple
  aggregation mechanism, so that you can depend on a collection of
  resources under a single name. In other words, OBazl takes the term
  "library" to mean "collection of resources"; the resources will
  almost always be OCaml compiled modules, but may include e.g.
  runtime data dependencies.

* The `ocaml_archive` rule supports OCaml archive files.

== Setup

To get the most out of OBazl and Bazel, you need to decide on some
conventions and do a little configuration. See link:obazl-conventions[OBazl
Conventions] for a list.

* shell scripts

== Inspecting the Bazel environment, logs, build actions, etc.

=== bazel info

The `bazel info` command will print a dictionary listing the
parameters, file locations, etc. that Bazel uses internally. It
supports a large number of options; run `$ bazel help info` to see them
all; to see just the keys for the dictionary, run `$ bazel help info-keys`.

Most of entries in the dictionary, most of the time, can be safely
ignored; but if you run into trouble, two of them can be helpful with
debugging: `command_log` and `output_base`.

=== command_log

Bazel writes logs to a `command_log` file each time it executes a
command; it overwrites the file. You can discover the location of the
file by running `$ bazel info command_log`. Since the output of this
command will overwrite the log file, you must use an alias or shell
script to enable easy browsing.  See the link:conventions.md#aliases[aliases]
recommendation in link:conventions.md[OBazl Conventions] for an example.

=== output_base

The `output_base` directory contains a subdirectory, `external`, that
contains the external repositories your project has configured. You
can browse the `BUILD.bazel` files of an external repo, for example,
to verify that you are using the correct target labels.

=== actions

A single build target may generate multiple build _actions_. For
example, if an `ocaml_module` rule is parameterized with a `ppx`
argument, it will generate two actions: one to transform the source
file with the PPX, and one to compile the result. Each action will
have a command line string.

Normally there is no need to pay these actions any mind, but if
something goes wrong with your build it may be useful to see exactly
what a build rule is doing - what the actions are, what commands and
arguments are used to run the actions, and what the inputs and outputs
are. Fortunately this is easy to do. You can use the [action query]()
facility to print all the actions generated by a rule without actually
running the rule (so it does not trigger any compilation). For
example, the following will print all the actions (and much additional
information) generated by the `//foo/bar:baz` target:

```
$ bazel aquery //foo/bar:baz
```

See link:transparency.md[Transparency] for more information.

==== Compile/link commands

**WARNING**: The current version of OBazl uses
link:http://projects.camlcity.org/projects/dl/findlib-1.8.1/doc/ref-html/r17.html#OCAMLFIND.OCAMLOPT[ocamlfind]
to drive the OCaml toolchain.  **The compile/link options for `ocamlfind` are different than those for the compilers `ocamlc` and `ocamlopt`.**

TODO: flesh this out a bit more.

== Useful tips

* The `clean` command "[r]emoves bazel-created output, including all
  object files, and bazel metadata." It will not refresh repository
  dependencies. Adding the `--expunge` option will delete everything;
  it will also stop the server, so that then next build command will
  start from scratch. You almost never need to do this.

* You should rarely need to run `$ bazel clean`. Bazel caches a
  complete description of the build, so it always knows what needs to
  be rebuilt. However, if you change the build structure - especially
  if you remove build targets - you may need this command to rebuild
  the cache.

* Do spend some time learning to use the query facilities. On a
  project of any size you'll be glad you did.

* To experiment with build rules etc. you can avoid cluttering the
  source tree by creating `dev/BUILD.bazel` and put the rules there.
  Since dependencies are expressed as target labels, you can reach
  into the tree anywhere you like, although you may need to adjust the
  `visibility` attribute of targets.

* Use link:https://github.com/bazelbuild/bazelisk[Bazelisk] to make sure
  you're always using the latest version of Bazel. You can pin the
  version you want by using a `.bazelversion` file.

* You can enable link:https://docs.bazel.build/versions/master/completion.html[command-line completion] (also known as tab-completion) in Bash and Zsh. This lets you tab-complete command names, flags names and flag values, and target names.  Caveat: tab-completion may be an issue for Bazelisk; see link:https://github.com/bazelbuild/bazelisk/issues/29[Support bash autocomplete #29].)

* If you need to make some kind of global change, e.g. renaming a
  target or adding a dependencie to multiple rules, do not
  search-and-replace. Use
  link:https://github.com/bazelbuild/buildtools/tree/master/buildozer[buildozer]
  instead.  (See link:maintenance.md#batch[Batch Editing] for more information.)

== Working with external repositories

* link:https://docs.bazel.build/versions/master/external.html[Working with External Dependencies]

Note in particular: link:https://docs.bazel.build/versions/master/external.html#transitive-dependencies[Transitive dependencies]

To coordinate development of a main directory and external
dependencies, you can override the declared repositories. See link:https://docs.bazel.build/versions/master/external.html#overriding-repositories-from-the-command-line[Overriding repositories from the command line].

Put your `--override` directives in your `user.bazelrc` file (by convention, `dev/user.bazelrc`), and load it from `.bazelrc` with the following line:  `try-import dev/user.bazelrc`
