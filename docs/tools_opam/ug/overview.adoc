---
layout: page_opam_ug
---

== Overview

The OPAM ecosystem is comprised of:

* a link:https://opam.ocaml.org/doc/Manual.html#Common-file-format[configuration language] used to describe OPAM repositories and packages;
* the link:https://opam.ocaml.org/doc/Usage.html[OPAM tool] used to manage OPAM repositories and installations ("switches")
* the official link:https://github.com/ocaml/opam-repository[OPAM repository] (custom repositories are also supported)
* local installations comprised of a set of "switches" and associated artifacts

An OPAM switch is comprised of one version of the OCaml toolchain plus
whatever OPAM packages the user chooses to install (using the OPAM
tool). Each switch gets its own set of installed packages, built using
the toolchain of that switch. The toolchain itself is built by OPAM.

An OPAM package is described by a file written in the OPAM
configuration lanuage and usually named `opam` or `<pkg>.opam`. The
metadata in this file includes a URL and checksum for the package
source code, a list of package dependencies, and a build
"recipe". Here are some examples:
link:https://github.com/ocaml/opam-repository/blob/master/packages/camlimages/camlimages.5.0.4/opam[camlimages.5.0.4];
link:https://github.com/ocaml/opam-repository/blob/master/packages/dns-client/dns-client.6.1.2/opam[dns-client.6.1.2];
link:https://github.com/ocaml/opam-repository/blob/master/packages/yojson/yojson.1.7.0/opam[yojson].

NOTE: the OPAM files for the `base-*` packages are essentially empty,
containing only opam-version, maintainer, and description fields.

The build recipe may use any tools. Many packages use link:https://dune.build/[dune], but
other build tools are also common, such as `make`, link:https://github.com/ocaml/ocamlbuild/blob/master/manual/manual.adoc[ocamlbuild], link:https://github.com/ocaml-omake/omake[omake], link:https://github.com/ocaml/oasis[oasis], etc. Some examples:

* link:https://github.com/ocaml/opam-repository/blob/master/packages/cmdliner/cmdliner.1.0.2/opam[cmdliner.1.0.2] - `ocaml pkg/pkg.ml build ...`
* link:https://github.com/ocaml/opam-repository/blob/master/packages/ppx_import/ppx_import.1.3/opam[ppx_import.1.3] - ocamlbuild

* link:https://github.com/ocaml/opam-repository/blob/master/packages/leveldb/leveldb.1.2.0/opam[leveldb.1.2.0] omake

* link:https://github.com/ocaml/opam-repository/blob/master/packages/planck/planck.2.2.0/opam[planck.2.2.0] -  `ocaml setup.ml -build`

The OCaml compiler itself is built by `./configure` and `make`.

=== The OPAM tool

In addition to managing package builds (that is, resolving
dependencies, downloading sources, and executing build scripts), the
OPAM tool can manage local OPAM repositories and switches.

Currently the OBazl toolsuite  is designed to work with the "current" switch.

The challenge:

1. control package versions (pinning)
2. build the same project with multiple switches (OCaml versions)

Item 2 could be handled using git branches, but what about people who
do not use git? can we assume that all VC systems have similar
functionality?


=== Hermetic builds

The essential requirements for build hermeticity are to put Bazel in complete control:

* Obtain source code. To reliably obtain the correct source, you must
  provide Bazel with a location (URI) and a checksum or digest such as
  a `SHA256` hash.
* Obtain the build tools. Ideally, the build tools themselves should
  be built from source.
* Run the build under the control of Bazel. Bazel will ensure that
  builds use only known tools with known inputs.

Of course, fully hermetic builds are not always required. For some
 projects they might be deemed essential for production builds, and
 they will almost always be necessary for remote builds, but in many
 development situations it will be acceptable to depend on prebuilt
 libraries installed in the local system. In particular, given the
 widespread adoption of OCaml, most developers will probably not
 object to using OPAM switches, including the OPAM-built OCaml
 toolchain, to build their OCaml software, at least during
 development.

OBazl tries to make it easy to go either way. The OBazl rules
themselves are hermetic, but hermeticity also depends on the tools and
libraries used, which may be out of Bazel's control.


=== External foreign dependencies

OCaml packages may depend on non-OCaml external libraries. A few examples:

* link:https://github.com/ocaml/opam-repository/blob/master/packages/leveldb/leveldb.1.3.0/opam[leveldb.1.3.0] - OCaml bindings for Google's LevelDB library

* link:https://github.com/ocaml/opam-repository/blob/master/packages/zarith/zarith.1.9.1/opam[zarith] - uses GMP

* link:https://github.com/ocaml/opam-repository/blob/master/packages/zlib/zlib.0.6/opam[zlib.0.6] - Bindings to the zlib compression library

Such dependencies will generally _not_ be mentioned in the `opam` file
(except informally, in the documentation string). But the build recipe
may provide a hint, for example by referring to the local system in
the build recipe, as in this fragment from `zarith.1.9.1` opam file:

```
  ["./configure"] {os != "openbsd" & os != "freebsd" & os != "macos"}
  [
    "sh"
    "-exc"
    "LDFLAGS=\"$LDFLAGS -L/usr/local/lib\" CFLAGS=\"$CFLAGS -I/usr/local/include\" ./configure"
  ] {os = "openbsd" | os = "freebsd"}
```

NOTE: OPAM version 2.1 supports `depext` dependencies. For example,
zarith lists `conf-gmp` as a dependency. That is a "virtual" package
that interrogates the system (using the same method used by the
traditional `./configure` script) to see if libgmp is installed, and fails
the build if it isn't. This is an improvement, but it still is not
enough. It does not constrain the version of the external resource,
and even if it did, it would still rely on precompiled resources. The
only secure and reliable method for handling resources is to compile
them from source.

But generally you will need to inspect the sources to determine the
exact dependencies. Even then, details on the dependency are rarely
provided. Often the package will simply include source code that
depends on whatever the build system can find in the local system. In
the above examples, the packages contain code that depends on headers
and library code for external libraries, but say nothing about how
this should be made available; they do not even mention which versions
are needed. At most, they include a dependency on an OPAM pkg-conf
virtual package that ensures that _some_ version of the needed library
is installed on the system. Needlesss to say, such packages compromise
hermeticity.

Furthermore, packages may depend on libraries produced by other
languages, such as `Go` or `Rust`. The source tarball might include
the foreign-language sources for the library, in which case the OPAM
build recipe would include directives for using the toolchain of the
language to build those sources. In that case, the toolchain will be
expected to already be installed on the local system, which again
compromises hermeticity (since the foreign toolchain itself is
unconstrained).

To acheive hermetic builds with such packages, the external resources
must be integrated into the Bazel build system. The OBazl rules can
depend on libraries produced by other compilers (C/C++, Rust, Go,
etc.) so long as they obey the standard C-based linkage conventions of
the operating system. More precisely, the OCaml compilers can link
such code, and the OBazl rules can arrange for this using a small set
of attributes (e.g. `cc_deps`, `cc_linkopts`, etc.).

But it is up to the developer to ensure that such libraries are
produced hermetically, and that means writing Bazel build targets for
them. For the most commonly used languages (C/C++, Rust, Go, Java,
Javascript, etc.), Bazel rulesets are available and can be used to
implement hermetic builds.

In some cases, tools are available to automate generation of the
needed Bazel code from the legacy build files. For Go, the
https://github.com/bazelbuild/bazel-gazelle[gazelle] tool can do this;
for Rust, the tool is https://github.com/google/cargo-raze[Raze]. For
C/C++ projects that use configure/make or cmake,
https://github.com/bazelbuild/rules_foreign_cc[rules_foreign_cc]
usually works quite well.

To sum up: to build hermetically using a package, like `zarith`, that
depends on a prebuilt external resource, you must write Bazel build
files that contain Bazel rules to build the external resource, and
OBazl rules to build `zarith` using the result.

=== dune notes

The Dune docs recommend the following in opam files:

.<pkg>.opam
```
build: [
  ["dune" "subst"] {pinned}
  ["dune" "build" "-p" name "-j" jobs]
]
```

"`-p pkg` is a shorthand for `--root . --only-packages pkg --profile release --default-target @install`. -p is the short version of --for-release-of-packages.

"This has the following effects:

* it tells dune to build everything that is installable and to ignore packages other than `name` defined in your project
* it sets the root to prevent dune from looking it up
* it silently ignores all rules with (mode promote)
* it sets the build profile to release
* it uses whatever concurrency option opam provides
* it sets the default target to @install rather than @@default

"Note that `name` and `jobs` are variables expanded by opam. name expands
to the [OPAM] package name and jobs to the number of jobs available to build
the package."

NB: the OPAM package name is the name of the containing directory for
`opam` files, and the `<pkg>` prefix for `<pkg>.opam` files.

In other words, in an OPAM file, Dune "build" means "build _and
install_". Installation copies artifacts to `$OPAM_SWITCH_PREFIX` subdirs, `lib`,
`bin`, etc.



=== misc notes

* controlling opam using bazel?

We can obtain opam files from the repo

We can parse them to discover URL, deps, build recipe, etc.

We could write our own parser, or we could use the (public) OPAM API

We can therefore ask Bazel to handle the src download

What about deps?  We could use the OPAM API again.

IOW we could write a custom OBazl wrapper using the OPAM API. But that
drops us into a viscious circle, since the OPAM tool is written in
OCaml. We would have to bootstrap by installing an OPAM switch to get
the process started.

If we could build the OCaml compiler using only Bazel (WIP) then using the
OPAM API would be fine.

In any case, given an opam file, we can download its sources, but what
about its deps? If we use the API to ask OPAM to resolve them, it
would end up downloading all the opam files for deps, recursively. So
why bother downloading any opam files in the first place, if OPAM is
going to do it anyway for the deps.

I guess the idea would be to ask OPAM to build the dep graph without
actually building anything. Should be possible.

Presumably OPAM is optimized to resolve deps for a set of pkgs. If we
tried to do it ourselves we would have to do graph merging etc. Or
would we? We could just read the opam, download the opam file for each
dep listed, and recur.  To avoid dups we could just cache work so far.

So suppose we get the depgraph and download all the opam files. Now we
can tell OPAM to run the build for each. But OPAM is going to use its
own switch to resolve deps during the build?

Note diff between deplist in OPAM file, and same in the buildfile. the
build tool won't know anything about the OPAM deplist.

We have the build deps (from the build files) and the meta-build deps
(OPAM). Must be kept in sync.

=== troubleshooting

To use an OBazl-configured opam switch, the `WORKSPACE.bazel` must
contain lines like the following:

```
load("//.obazl.d/opam/_here:opam_repos.bzl", "fetch")
fetch()
```

If you delete the generated files (in `.obazl.d/opam`) then running
any Bazel command will result in an error like the following:

```
bazel build hello
ERROR: error loading package '': Label '//.obazl.d/opam/obazl:opam_repos.bzl' is invalid because '.obazl.d/opam/obazl' is not a package; perhaps you meant to put the colon here: '//:.obazl.d/opam/obazl/opam_repos.bzl'?
```

The fix would be to rerun `@opam//here/config`; but that will run into
the same error. So the trick is to first comment out the lines in
`WORKSPACE.bazel`, run `@opam//here/config`, and then re-enable the
workspace lines.  Normally this will not be required.


=== initialization

After `@opam//here/init -- -c <version>`, the switch can be configured
using `@opam//here/install` and `@opam//here/remove`. To install a
large number of packages, a "manifest" file (as produced by `opam
export`) can be imported, so long as the compiler version matches. Form:

```
opam-version: "2.1"
compiler: ["ocaml-base-compiler.4.13.0"]
roots: [
       ...pkgs ...
]
installed: [
   ...pkgs ...
]
```

You can edit the file to make the compiler version match that of the here-switch.

Once the here-switch is configured, `@opam//here/export` will generate
`.obazl.d/opam/here.packages`, which can be used along with
`.obazl.d/opam/here.compiler` to recreate the switch with a single
`@opam//here/init` command.
